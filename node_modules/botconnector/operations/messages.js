/*
 * Code generated by Microsoft (R) AutoRest Code Generator 0.13.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var WebResource = msRest.WebResource;

/**
 * @class
 * Messages
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the ConnectorClient.
 * Initializes a new instance of the Messages class.
 * @constructor
 *
 * @param {ConnectorClient} client Reference to the service client.
 */
function Messages(client) {
  this.client = client;
}

/**
 * @summary Send a message
 *
 * This method allows you to initiate a new conversation message with the
 * user.
 * 
 * The important fields are:
 * 
 * |Property    | Description
 * |Example
 * 
 * |------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 * ------------------------------------
 * |From        | The ChannelAccount of the Bot you want to send the message
 * from
 * |
 * SMS:+4255551212 (the bots address)
 * |To          | The channelAccount of the user you to start a conversation
 * with
 * |
 * SMS:+4255551111 (the users address)
 * |Text        | The message you want to communicate
 * |
 * Text: "Hello world"
 * |Language    | The language your message is expressed in (important if you
 * have translation enabled) using the [language codes from Microsoft
 * Translator](https://msdn.microsoft.com/en-us/library/hh456380.aspx) |
 * Language: "en"
 * |Attachments | Attachments represent images and attachments that will be
 * rendered on the platform as appropriate
 * |
 * ...
 * |ChannelData | You can pass channel specific data to get custom native
 * rendering of your message on a per channel basis. See channel
 * documentation for information on what channels are expecting for this
 * | ...
 * 
 * Bots can track state data by User, Conversation and Users within the
 * Conversation by embedding data objects into the message.
 * This data will be stored in persistent storage and reflected back to the
 * bot with all future messages as appropriate to their scope.
 * 
 * The properties you use to for Bot State are:
 * 
 * |Property                   | Description
 * |
 * Example
 * |-------------------------- |
 * ----------------------------------------------------------------------------------------------------
 * | --------------------------------------------------------------
 * |BotUserData                |  Bot controlled Object which is tracked on
 * the user regardless of the channel they communicate on    | BotUserData: {
 * 'Welcomed' : true }
 * |BotConversationData        | Bot controlled object which is tracked on the
 * conversation regardless of the user you are talking to |
 * BotConversationData:  'MessageCount':13 }
 * |BotPerUserConversationData | Bot controlled object which is tracked on a
 * user in a given conversation                             |
 * BotPerUserConversationData : {'LastRequest' : 'FavoriteColor' }
 *
 * @param {object} message message to send
 * 
 * @param {string} [message.type] The type of the message. Possible values for
 * this property include: 'Message', 'Ping', 'DeleteUserData',
 * 'BotAddedToConversation', 'BotRemovedFromConversation',
 * 'UserAddedToConversation', 'UserRemovedFromConversation',
 * 'EndOfConversation'.
 * 
 * @param {string} [message.id] Id for the message (always assigned by
 * transport)
 * 
 * @param {string} [message.conversationId] Bot.Connector ConverationId id
 * (always assigned by transport)
 * 
 * @param {date} [message.created] Timestamp of when the message was created
 * 
 * @param {string} [message.sourceText] (if translated) The OriginalText of
 * the message
 * 
 * @param {string} [message.sourceLanguage] (if translated) The language of
 * the original message.
 * 
 * @param {string} [message.language] The language code of the Text field
 * 
 * @param {string} [message.text] The text of the message
 * 
 * @param {array} [message.attachments] Array of content attachments to things
 * like images
 * 
 * @param {object} [message.from] ChannelAccount of the user or bot that is
 * sending the message
 * 
 * @param {object} [message.to] ChannelAccount of hte user or bot the message
 * is being routed to
 * 
 * @param {string} [message.to.name] Display friendly name of the user or bot
 * 
 * @param {string} [message.to.channelId] Channel Id that the channelAccount
 * is to be communicated with (Example: slack, sms, email, groupme, skype,
 * twitter, etc.)
 * 
 * @param {string} [message.to.address] Channel Address for the channelAccount
 * (Example: joe@smith.com, or @joesmith or 123456)
 * 
 * @param {string} [message.to.id] Id - id of the shared bot or user this
 * channelaccount refers to
 * 
 * @param {boolean} [message.to.isBot] Is this id a bot?
 * 
 * @param {string} [message.replyToMessageId] The message Id that this message
 * is a reply to
 * 
 * @param {array} [message.participants] List of ChannelAccounts in the
 * conversation
 * 
 * @param {number} [message.totalParticipants] Total participants in the
 * conversation.  2 means 1:1 message  User - Bot
 * 
 * @param {array} [message.mentions] Array of mentions from the channel context
 * 
 * @param {string} [message.place] Place in user readable format:
 * 
 * @param {string} [message.channelMessageId] Channel Message Id
 * 
 * @param {string} [message.channelConversationId] Channel Conversation Id
 * 
 * @param {object} [message.channelData] Channel specific payload
 * 
 * @param {object} [message.botUserData] Bot's User data object
 * 
 * @param {object} [message.botConversationData] Bot's Conversation Data object
 * 
 * @param {object} [message.botPerUserInConversationData] Bot's Per User in a
 * conversation data object
 * 
 * @param {object} [message.location] Location information (see
 * https://dev.onedrive.com/facets/location_facet.htm)
 * 
 * @param {number} [message.location.altitude] Altitude
 * 
 * @param {number} [message.location.latitude] Latitude for the user when the
 * message was created
 * 
 * @param {number} [message.location.longitude] Longitude for the user when
 * the message was created
 * 
 * @param {string} [message.location.name] Name for user location when the
 * message was created
 * 
 * @param {array} [message.hashtags] Hashtags for the message
 * 
 * @param {string} [message.eTag]
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
Messages.prototype.sendMessage = function (message, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (message === null || message === undefined) {
      throw new Error('message cannot be null or undefined.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//bot/v1.0/messages';
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  // Serialize Request
  var requestContent = null;
  var requestModel = null;
  try {
    if (message) {
      requestModel = new client._models['Message'](message);
    }
    if (requestModel !== null && requestModel !== undefined) {
      requestContent = JSON.stringify(requestModel.serialize());
    } else {
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    var serializationError = new Error(util.format('Error "%s" occurred in serializing the payload - "%s"', error, util.inspect(requestModel, {depth: null})));
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  httpRequest.headers['Content-Length'] = Buffer.isBuffer(requestContent) ? requestContent.length : Buffer.byteLength(requestContent, 'UTF8');
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = httpRequest;
      error.response = response;
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody - "%s" for the default response.', defaultError, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse) {
          result = new client._models['Message'](parsedResponse);
        }
        if (parsedResponse !== null && parsedResponse !== undefined) {
          result.deserialize(parsedResponse);
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = httpRequest;
        deserializationError.response = response;
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse) {
          result = new client._models['ErrorMessage'](parsedResponse);
        }
        if (parsedResponse !== null && parsedResponse !== undefined) {
          result.deserialize(parsedResponse);
        }
      } catch (error) {
        var deserializationError1 = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError1.request = httpRequest;
        deserializationError1.response = response;
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse) {
          result = new client._models['ErrorMessage'](parsedResponse);
        }
        if (parsedResponse !== null && parsedResponse !== undefined) {
          result.deserialize(parsedResponse);
        }
      } catch (error) {
        var deserializationError2 = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError2.request = httpRequest;
        deserializationError2.response = response;
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse) {
          result = new client._models['ErrorMessage'](parsedResponse);
        }
        if (parsedResponse !== null && parsedResponse !== undefined) {
          result.deserialize(parsedResponse);
        }
      } catch (error) {
        var deserializationError3 = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError3.request = httpRequest;
        deserializationError3.response = response;
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse) {
          result = new client._models['ErrorMessage'](parsedResponse);
        }
        if (parsedResponse !== null && parsedResponse !== undefined) {
          result.deserialize(parsedResponse);
        }
      } catch (error) {
        var deserializationError4 = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError4.request = httpRequest;
        deserializationError4.response = response;
        return callback(deserializationError4);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};


module.exports = Messages;
