{
  "name": "chrono-node",
  "description": "A natural language date parser in Javascript",
  "homepage": "http://github.com/berryboy/chrono",
  "repository": {
    "type": "git",
    "url": "https://github.com/berryboy/chrono.git"
  },
  "license": "MIT",
  "version": "1.2.3",
  "directories": {
    "source": "./src",
    "test-qunit": "./test-qunit"
  },
  "main": "./src/chrono",
  "devDependencies": {
    "browserify": "^6.3.3",
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.5",
    "karma": "~0.10.4",
    "karma-browserify": "^1.0.0",
    "karma-chrome-launcher": "~0.1.0",
    "karma-firefox-launcher": "~0.1.0",
    "karma-qunit": "~0.1.1",
    "minifyify": "^7.0.6",
    "qunit": "git://github.com/wanasit/node-qunit.git",
    "watchify": "^2.1.1"
  },
  "scripts": {
    "make-bundle": "browserify src/chrono.js -d --s chrono -o chrono.js",
    "make-minify": "browserify src/chrono.js -d --s chrono -d -p [minifyify --output chrono.map.json] -o chrono.min.js",
    "make": "npm run make-bundle & npm run make-minify",
    "watch": "watchify src/chrono.js -d --s chrono -o chrono.js",
    "karma": "karma start",
    "test": "qunit -l '{summary:true, tests: true}' -c chrono:src/chrono.js -p src -t test/*.js --cov",
    "coveralls": "npm run test && cat coverage/lcov.info | coveralls"
  },
  "dependencies": {
    "moment": "^2.10.3"
  },
  "readme": "Chrono\n======\nA natural language date parser in Javascript, designed for extracting date information from any given text. (Java version is also available [here](https://github.com/wanasit/chrono-java))\n\n[![Build Status](https://travis-ci.org/wanasit/chrono.svg?branch=master)](https://travis-ci.org/wanasit/chrono)\n[![Coverage Status](https://img.shields.io/coveralls/wanasit/chrono.svg)](https://coveralls.io/r/wanasit/chrono?branch=master)\n\nChrono supports most date and time formats, such as :\n\n* Today, Tomorrow, Yesterday, Last Friday, etc\n* 17 August 2013 - 19 August 2013\n* This Friday from 13:00 - 16.00\n* 5 days ago\n* Sat Aug 17 2013 18:40:39 GMT+0900 (JST)\n* 2014-11-30T08:15:30-05:30\n\n## Install\n\n#### Node.js \n\n    npm install chrono-node\n\n#### Bower\n\n    bower install chrono\n\n#### CDN\n\nVia [jsDelivr](https://www.jsdelivr.com/projects/chrono):\n\n```html\n<script src=\"https://cdn.jsdelivr.net/chrono/VERSION/chrono.min.js\"></script>\n```\n\n#### Rails\n\n```ruby\nsource 'https://rails-assets.org' do\n  gem 'rails-assets-chrono'\nend\n```\n\n#### Browserify\n\nChrono's modules are linked and packaged using [Browserify](http://browserify.org) on `src/chrono.js`. By default, `chrono.js` file exports `chrono` object as a window global.\n\n```\nbrowserify src/chrono.js --s chrono -o chrono.js\n```\n\n## USAGE\n\nSimply pass a string to function `chrono.parseDate` or `chrono.parse`. \n\n```javascript\n> var chrono = require('chrono-node')\n\n> chrono.parseDate('An appointment on Sep 12-13') \nFri Sep 12 2014 12:00:00 GMT-0500 (CDT)\n    \n> chrono.parse('An appointment on Sep 12-13');\n[ { index: 18,\n    text: 'Sep 12-13',\n    tags: { ENMonthNameMiddleEndianParser: true },\n    start: \n     { knownValues: [Object],\n       impliedValues: [Object] },\n    end: \n     { knownValues: [Object],\n       impliedValues: [Object] } } ]\n```\n\n### Reference Date\n\nToday's \"Friday\" is different from last month's \"Friday\". \nThe meaning of the referenced dates depends on when they are mentioned. \nChrono lets you define a reference date using `chrono.parse(text, ref)` and `chrono.parseDate(text, ref)`.    \n\n```javascript\n\n> chrono.parseDate('Friday', new Date(2012,7,23)); \nFri Aug 24 2012 12:00:00 GMT+0700 (ICT)\n\n> chrono.parseDate('Friday', new Date(2012,7,1)); \nFri Aug 03 2012 12:00:00 GMT+0700 (ICT)\n```\n\n### Detailed Parsed Results\n\nThe function `chrono.parse` returns detailed parsing results as objects of class `chrono.ParsedResult`. \n\n```javascript\nvar results = chrono.parse('I have an appointment tomorrow from 10 to 11 AM')\n\nresults[0].index  // 15\nresults[0].text   // 'tomorrow from 10 to 11 AM'\nresults[0].ref    // Sat Dec 13 2014 21:50:14 GMT-0600 (CST)\n\nresults[0].start.date()  // Sun Dec 14 2014 10:00:00 GMT-0600 (CST)\nresults[0].end.date()    // Sun Dec 14 2014 11:00:00 GMT-0600 (CST)\n```\n\n#### ParsedResult\n\n* `start` The parsed date components as a [ParsedComponents](#parsedcomponents) object\n* `end`   Similar to `start` but can be null.\n* `index` The location within the input text of this result  \n* `text`  The text this result that appears in the input \n* `ref`   The [reference date](#reference-date) of this result\n\n#### ParsedComponents\n\nA group of found date and time components (year, month, hour, etc). ParsedComponents objects consist of `knownValues` and `impliedValues`.\n\n* `assign(component, value)`  Set known value to the component\n* `imply(component, value)`   Set implied value to the component\n* `get(component)`            Get known or implied value for the component\n* `isCertain(component)`      return true if the value of the component is known.\n* `date()`                    Create a javascript Date\n\n## Customize Chrono\n\nChrono’s extraction pipeline are mainly separated into 'parse' and ‘refine’ phases. During parsing, ‘parsers’ (`Parser`) are used to extract patterns from the input text. The parsed results ([ParsedResult](#parsedresult)) are the combined, sorted, then refine using ‘refiners’ (`Refiner`). In the refining phase, the results can be combined, filtered-out, or attached with additional information.\n\n### Parser\n\nParser is a module for low-level pattern-based parsing. Ideally, each parser should be designed to handle a single specific date format. User can add new type of parsers for supporting new date formats or languages.\n\n```javascript\nvar christmasParser = new chrono.Parser();\n\n// Provide search pattern\nchristmasParser.pattern = function () { return /Christmas/i } \n\n// This function will be called when matched pattern is found\nchristmasParser.extract = function(text, ref, match, opt) { \n    \n    // Return a parsed result, that is 25 December\n    return new chrono.ParsedResult({\n        ref: ref,\n        text: match[0],\n        index: match.index,\n        start: {    \n            day: 25, \n            month: 12, \n        }\n    });\n}\n\nvar custom = new chrono.Chrono();\ncustom.parsers.push(christmasParser);\n\ncustom.parseDate(\"I'll arrive at 2.30AM on Christmas night\") \n// Wed Dec 25 2013 02:30:00 GMT+0900 (JST)\n\n```\n\nTo create a custom parser, override `pattern` and `extract` methods on an object of class `chrono.Parser`. \n* The `pattern` method must return `RegExp` object of searching pattern. \n* The `extract` method will be called with the \n[match](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec) object when the pattern is found. This function must create and return a [result](#parsedresult) (or null to skip).\n\n### Refiner\n\nRefiner is a heigher level module for improving or manipurating the results. User can add a new type of refiner to customize Chrono's results or to add some custom logic to Chrono.\n\n```javascript\nvar guessPMRefiner = new chrono.Refiner();\nguessPMRefiner.refine = function(text, results, opt) {\n    // If there is no AM/PM (meridiem) specified, \n    //  let all time between 1:00 - 4:00 be PM (13.00 - 16.00)\n    results.forEach(function (result) {\n        if (!result.start.isCertain('meridiem') \n            &&  result.start.get('hour') >= 1 && result.start.get('hour') < 4) {\n            \n            result.start.assign('meridiem', 1);\n            result.start.assign('hour', result.start.get('hour') + 12);\n        }\n    });\n    return results;\n} \n\nvar custom = new chrono.Chrono();\ncustom.refiners.push(guessPMRefiner);\n\n// This will be parsed as PM.\n// > Tue Dec 16 2014 14:30:00 GMT-0600 (CST) \ncustom.parseDate(\"This is at 2.30\");\n\n// Unless the 'AM' part is specified\n// > Tue Dec 16 2014 02:30:00 GMT-0600 (CST)\ncustom.parseDate(\"This is at 2.30 AM\");\n```\n\nIn the example, a custom refiner is created for assigning PM to parsing results with ambiguous [meridiem](http://en.wikipedia.org/wiki/12-hour_clock). The `refine` method of the refiner class will be called with parsing [results](#parsedresult) (from [parsers](#parser) or other previous refiners). The method must return an array of the new results (which, in this case, we modified those results in place).\n\n\n## Development Guides\n\nThis guide explains how to setup chrono project for prospective contributors.\n\n```bash\n# Clone and install library\ngit clone https://github.com/wanasit/chrono.git chrono\ncd chrono\nnpm install\n\n# Try running the test\nnpm run test\n```\n\nChrono's source files is in `src` directory. The built bundle (`chrono.js` and `chrono.min.js`) can be built by [Browserify](http://browserify.org) on `src/chrono.js` using the following command \n\n```\nnpm run make\n```\n\nParsing date from text is complicated. Sometimes, a small change can have effects on unexpected places. So, Chrono is a heavily tested library. Commits that break a test shouldn't be allowed in any condition.\n\nChrono's unit testing is based-on [Qunit](https://qunitjs.com/) and [Karma](https://github.com/karma-runner/karma). During the developement, I recommend running Karma test together with watchify.\n\n```\n# Start karma\nnpm run karma\n\n# Start watch (run on a different terminal)\nnpm run watch\n```\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/berryboy/chrono/issues"
  },
  "_id": "chrono-node@1.2.3",
  "dist": {
    "shasum": "de6c587b1673aabc7354c8c7f9b2c80db32b5cbe"
  },
  "_from": "chrono-node@^1.1.3",
  "_resolved": "https://registry.npmjs.org/chrono-node/-/chrono-node-1.2.3.tgz"
}
